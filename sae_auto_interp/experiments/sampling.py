import random
import torch

from ..logger import logger

# The functions in this file were generated by Claude 3.5

def sample_quantiles(
    record,
    n_train=10,
    n_test=5,
    n_quantiles=2,
    n_extra=0,
    seed=22,
):
    """
    Split a record's examples into quantiles based on fractions 
    of the max activation and sample from each quantile.

    Args:
        record (FeatureRecord): The record to sample from.
        n_train (int): The number of examples to sample for training.
        n_test (int): The number of examples to sample for testing.
        n_quantiles (int): The number of quantiles to split the examples into.
        n_extra (int): The number of extra examples to sample randomly from remaining examples.
        seed (int): The random seed to use for reproducibility.

    Returns:
        Tuple[List[Example], List[List[Example]], List[Example]]: A tuple containing the training examples,
        a list of test examples for each quantile, and a list of extra examples.
    """
    random.seed(seed)
    torch.manual_seed(seed)  # Also set torch seed for reproducibility

    if len(record.examples) < n_train + (n_test * (n_quantiles - 1)) + n_extra:
        logger.error(f"Not enough examples in record {record} for the requested sampling")
        raise ValueError(f"Not enough examples in record {record} for the requested sampling")

    # Extract max activations from examples
    max_activations = torch.tensor([example.max_activation for example in record.examples])
    
    # Calculate thresholds based on fractions of the overall maximum activation
    overall_max = max_activations.max().item()
    thresholds = [overall_max * (i + 1) / n_quantiles for i in range(n_quantiles - 1)]
    
    quantiles = []
    start = 0
    for i, end in enumerate(thresholds):
        # Filter examples in this quantile
        quantile_examples = [
            example for example in record.examples
            if start <= example.max_activation < end
        ]
        
        n_samples = n_train if i == 0 else n_test

        if len(quantile_examples) < n_samples:
            logger.error(f"Quantile {i} has too few examples in record {record}")
            raise ValueError(f"Quantile {i} has too few examples in record {record}")
        
        quantile_sample = random.sample(quantile_examples, n_samples)
        quantiles.append(quantile_sample)
        
        start = end
    
    # Add the last quantile
    last_quantile = [
        example for example in record.examples
        if example.max_activation >= start
    ]
    n_samples = min(n_test, len(last_quantile))
    quantiles.append(random.sample(last_quantile, n_samples))
    
    if n_extra > 0:
        # Create a set of all examples in train and test sets
        used_examples = set(example for quantile in quantiles for example in quantile)
        
        # Sample n_extra examples from the remaining examples
        remaining_examples = [example for example in record.examples if example not in used_examples]
        extra_examples = random.sample(remaining_examples, min(n_extra, len(remaining_examples)))

        return quantiles[0], quantiles[1:], extra_examples
    else:
        return quantiles[0], quantiles[1:]


def sample_random_and_quantiles(
    record,
    n_train=10,
    n_test=5,
    n_quantiles=2,
    seed=22,
):
    """
    Randomly sample training examples from all activations, then split the rest into
    quantiles based on fractions of the max activation and sample from each quantile for testing.

    Args:
        record (FeatureRecord): The record to sample from.
        n_train (int): The number of examples to sample for training.
        n_test (int): The number of examples to sample for testing from each quantile.
        n_quantiles (int): The number of quantiles to split the remaining examples into.
        seed (int): The random seed to use for reproducibility.

    Returns:
        Tuple[List[Example], List[List[Example]]]: A tuple containing the training examples
        and a list of test examples for each quantile.
    """
    random.seed(seed)
    torch.manual_seed(seed)  # Also set torch seed for reproducibility

    if len(record.examples) < n_train + (n_test * n_quantiles):
        logger.error(f"Not enough examples in record {record} for the requested sampling")
        raise ValueError(f"Not enough examples in record {record} for the requested sampling")

    # Randomly sample n_train examples for training and remove
    train_examples = random.sample(record.examples, n_train)
    remaining_examples = [ex for ex in record.examples if ex not in train_examples]

    # Extract max activations from remaining examples
    max_activations = torch.tensor([example.max_activation for example in remaining_examples])

    # Calculate thresholds based on fractions of the overall maximum activation
    overall_max = max_activations.max().item()
    thresholds = [overall_max * (i + 1) / n_quantiles for i in range(n_quantiles - 1)]
    
    quantiles = []
    start = 0
    for i, end in enumerate(thresholds):
        # Filter examples in this quantile
        quantile_examples = [
            example for example in remaining_examples
            if start <= example.max_activation < end
        ]
        
        if len(quantile_examples) < n_test:
            logger.error(f"Quantile {i} has too few examples in record {record}")
            raise ValueError(f"Quantile {i} has too few examples in record {record}")
        
        quantile_sample = random.sample(quantile_examples, n_test)
        quantiles.append(quantile_sample)
        
        start = end
    
    # Add the last quantile
    last_quantile = [
        example for example in remaining_examples
        if example.max_activation >= start
    ]

    if len(last_quantile) < n_test:
        logger.error(f"Last quantile has too few examples in record {record}")
        raise ValueError(f"Last quantile has too few examples in record {record}")
    quantiles.append(random.sample(last_quantile, n_test))
    
    return train_examples, quantiles